import logging
import asyncio
import requests
import schedule
from bs4 import BeautifulSoup
from telegram import Update, ReplyKeyboardMarkup
from telegram.ext import ApplicationBuilder, CommandHandler, ContextTypes
from datetime import datetime, timedelta
import json
import os

# –ü–æ–ª—É—á–∞–µ–º —Ç–æ–∫–µ–Ω –∏–∑ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è (–¥–ª—è Heroku)
TELEGRAM_TOKEN = os.getenv("TELEGRAM_TOKEN")

SUBSCRIBERS_FILE = 'subscribers.json'

logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)

def load_subscribers():
    if os.path.exists(SUBSCRIBERS_FILE):
        with open(SUBSCRIBERS_FILE, 'r') as f:
            return set(json.load(f))
    return set()

def save_subscribers(subscribers):
    with open(SUBSCRIBERS_FILE, 'w') as f:
        json.dump(list(subscribers), f)

async def send_commands_menu(update: Update):
    keyboard = [
        ["/start", "/unsubscribe"],
        ["/schedule", "/ranking"],
    ]
    reply_markup = ReplyKeyboardMarkup(keyboard, resize_keyboard=True, one_time_keyboard=False)
    await update.message.reply_text("–í—ã–±–µ—Ä–∏—Ç–µ –∫–æ–º–∞–Ω–¥—É:", reply_markup=reply_markup)

def get_upcoming_tournament_tomorrow():
    # –≠—Ç–∞ —Ñ—É–Ω–∫—Ü–∏—è —Å–µ–π—á–∞—Å –Ω–µ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –¥–ª—è —Ç–µ—Å—Ç–∞, –æ—Å—Ç–∞–≤–ª—è—é –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π
    try:
        url = "https://en.wikipedia.org/wiki/2025%E2%80%9326_snooker_season"
        response = requests.get(url)
        soup = BeautifulSoup(response.text, 'html.parser')

        tomorrow = datetime.now().date() + timedelta(days=1)

        tables = soup.find_all('table', {'class': 'wikitable'})
        target_table = None
        for table in tables:
            header = table.find('tr')
            headers = [th.get_text(strip=True) for th in header.find_all(['th', 'td'])]
            needed_headers = {'Start', 'Finish', 'Tournament'}
            if needed_headers.issubset(set(headers)):
                target_table = table
                break

        if not target_table:
            return None

        rows = target_table.find_all('tr')[1:]

        for row in rows:
            cols = row.find_all('td')
            if len(cols) >= 3:
                start_date_str = cols[0].get_text(strip=True)
                try:
                    start_date = datetime.strptime(start_date_str, "%d %B %Y").date()
                except Exception:
                    try:
                        start_date = datetime.strptime(start_date_str, "%B %Y").date()
                        start_date = start_date.replace(day=1)
                    except Exception:
                        continue

                if start_date == tomorrow:
                    tournament = cols[2].get_text(strip=True)
                    return f"üé± –ó–∞–≤—Ç—Ä–∞ —Å—Ç–∞—Ä—Ç—É–µ—Ç —á–µ–º–ø–∏–æ–Ω–∞—Ç:\nüèÜ {tournament}\nüìÖ {start_date_str}"

        return None
    except Exception as e:
        return f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–æ–≤–µ—Ä–∫–µ —Ç—É—Ä–Ω–∏—Ä–æ–≤: {e}"

def get_schedule():
    try:
        url = "https://en.wikipedia.org/wiki/2025%E2%80%9326_snooker_season"
        response = requests.get(url)
        soup = BeautifulSoup(response.text, 'html.parser')

        tables = soup.find_all('table', {'class': 'wikitable'})

        target_table = None
        for table in tables:
            header = table.find('tr')
            headers = [th.get_text(strip=True) for th in header.find_all(['th', 'td'])]
            needed_headers = {'Start', 'Finish', 'Tournament'}
            if needed_headers.issubset(set(headers)):
                target_table = table
                break

        if not target_table:
            return "–ù–µ —É–¥–∞–ª–æ—Å—å –Ω–∞–π—Ç–∏ —Ç–∞–±–ª–∏—Ü—É —Ç—É—Ä–Ω–∏—Ä–æ–≤."

        rows = target_table.find_all('tr')[1:]
        results = []
        for row in rows:
            cols = row.find_all('td')
            if len(cols) >= 3:
                start = cols[0].get_text(strip=True)
                finish = cols[1].get_text(strip=True)
                tournament = cols[2].get_text(strip=True)
                results.append(f"üìÖ {start} ‚Äî {finish}\nüèÜ {tournament}")

        if not results:
            return "–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –æ —Ç—É—Ä–Ω–∏—Ä–∞—Ö."

        return "\n\n".join(results)

    except Exception as e:
        return f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è: {e}"

def get_world_ranking():
    try:
        url = "https://en.wikipedia.org/wiki/Snooker_world_rankings"
        response = requests.get(url)
        soup = BeautifulSoup(response.text, 'html.parser')

        tables = soup.find_all('table', {'class': 'wikitable'})
        ranking_table = None
        for table in tables:
            headers = [th.text.strip() for th in table.find_all('th')]
            if 'Points' in headers and 'Player' in headers:
                ranking_table = table
                break
        if not ranking_table:
            return "–ù–µ —É–¥–∞–ª–æ—Å—å –Ω–∞–π—Ç–∏ —Ç–∞–±–ª–∏—Ü—É —Ä–µ–π—Ç–∏–Ω–≥–∞."

        rows = ranking_table.find_all('tr')[1:]  # –≤—Å–µ –∏–≥—Ä–æ–∫–∏
        results = []
        for row in rows:
            cols = row.find_all(['td', 'th'])
            if len(cols) >= 3:
                position = cols[0].text.strip()
                player = cols[1].text.strip()
                points = cols[2].text.strip()
                results.append(f"{position}. {player} ‚Äî {points} –æ—á–∫–æ–≤")

        if not results:
            return "–†–µ–π—Ç–∏–Ω–≥ –ø—É—Å—Ç."

        return "üèÜ –ú–∏—Ä–æ–≤–æ–π —Ä–µ–π—Ç–∏–Ω–≥ —Å–Ω—É–∫–µ—Ä–∞:\n\n" + "\n".join(results)

    except Exception as e:
        return f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Ä–µ–π—Ç–∏–Ω–≥–∞: {e}"

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = str(update.effective_chat.id)
    subscribers = load_subscribers()
    message_text = ("‚è∞ –£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ —Ç—É—Ä–Ω–∏—Ä–∞—Ö –±—É–¥—É—Ç –ø—Ä–∏—Ö–æ–¥–∏—Ç—å –∑–∞ –¥–µ–Ω—å –¥–æ –Ω–∞—á–∞–ª–∞, –ø—Ä–∏–º–µ—Ä–Ω–æ –≤ 21:00.\n\n")
    if user_id not in subscribers:
        subscribers.add(user_id)
        save_subscribers(subscribers)
        await update.message.reply_text("‚úÖ –¢—ã –ø–æ–¥–ø–∏—Å–∞–Ω –Ω–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ —Å–Ω—É–∫–µ—Ä–µ.\n\n" + message_text)
    else:
        await update.message.reply_text("‚úÖ –¢—ã —É–∂–µ –ø–æ–¥–ø–∏—Å–∞–Ω.\n\n" + message_text)
    await send_commands_menu(update)

async def unsubscribe(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = str(update.effective_chat.id)
    subscribers = load_subscribers()
    if user_id in subscribers:
        subscribers.remove(user_id)
        save_subscribers(subscribers)
        await update.message.reply_text("‚úÖ –¢—ã –æ—Ç–ø–∏—Å–∞–Ω –æ—Ç —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π –æ —Å–Ω—É–∫–µ—Ä–µ.")
    else:
        await update.message.reply_text("‚ö†Ô∏è –¢—ã –Ω–µ –±—ã–ª –ø–æ–¥–ø–∏—Å–∞–Ω.")
    await send_commands_menu(update)

async def schedule_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text("‚è≥ –ü–æ–ª—É—á–∞—é —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ —á–µ–º–ø–∏–æ–Ω–∞—Ç–æ–≤...")
    data = get_schedule()
    if len(data) > 3900:
        data = data[:3900] + "\n\n...–∏ –µ—â—ë —Ç—É—Ä–Ω–∏—Ä—ã –¥–æ—Å—Ç—É–ø–Ω—ã –Ω–∞ –í–∏–∫–∏–ø–µ–¥–∏–∏."
    await update.message.reply_text(data)
    await send_commands_menu(update)

async def ranking_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text("‚è≥ –ü–æ–ª—É—á–∞—é —Ç–µ–∫—É—â–∏–π –º–∏—Ä–æ–≤–æ–π —Ä–µ–π—Ç–∏–Ω–≥...")
    data = get_world_ranking()
    max_len = 4000
    if len(data) <= max_len:
        await update.message.reply_text(data)
    else:
        parts = []
        current = ""
        for line in data.split("\n"):
            if len(current) + len(line) + 1 > max_len:
                parts.append(current)
                current = ""
            current += line + "\n"
        if current:
            parts.append(current)
        for part in parts:
            await update.message.reply_text(part)
    await send_commands_menu(update)

# –ù–æ–≤—ã–π —Ç–µ—Å—Ç–æ–≤—ã–π —É–≤–µ–¥–æ–º–ª—è—é—â–∏–π —Ç–∞—Å–∫ ‚Äî –æ—Ç–ø—Ä–∞–≤–∏—Ç —Å–æ–æ–±—â–µ–Ω–∏–µ —á–µ—Ä–µ–∑ 1 –º–∏–Ω—É—Ç—É –ø–æ—Å–ª–µ –∑–∞–ø—É—Å–∫–∞
async def test_notify_after_delay(application, delay_seconds=60):
    await asyncio.sleep(delay_seconds)
    subscribers = load_subscribers()
    text = "‚úÖ –¢–µ—Å—Ç–æ–≤–æ–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ: –±–æ—Ç —Ä–∞–±–æ—Ç–∞–µ—Ç –∏ –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏—è!"
    for chat_id in subscribers:
        try:
            await application.bot.send_message(chat_id=chat_id, text=text)
            logging.info(f"–û—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ —Ç–µ—Å—Ç–æ–≤–æ–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ {chat_id}")
        except Exception as e:
            logging.warning(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ —Ç–µ—Å—Ç–æ–≤–æ–≥–æ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è {chat_id}: {e}")

async def on_startup(app):
    # –ó–∞–ø—É—Å–∫–∞–µ–º —Ç–µ—Å—Ç–æ–≤–æ–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ —á–µ—Ä–µ–∑ 60 —Å–µ–∫—É–Ω–¥ –ø–æ—Å–ª–µ —Å—Ç–∞—Ä—Ç–∞
    asyncio.create_task(test_notify_after_delay(app, 60))
    # –ï—Å–ª–∏ —Ö–æ—á–µ—à—å, –º–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å –æ–±—ã—á–Ω—ã–π scheduler, –Ω–æ –ø–æ–∫–∞ —É–±—Ä–∞–ª
    # asyncio.create_task(scheduler(app))

if __name__ == '__main__':
    import nest_asyncio
    nest_asyncio.apply()

    app = ApplicationBuilder().token(TELEGRAM_TOKEN).post_init(on_startup).build()
    app.add_handler(CommandHandler("start", start))
    app.add_handler(CommandHandler("unsubscribe", unsubscribe))
    app.add_handler(CommandHandler("schedule", schedule_command))
    app.add_handler(CommandHandler("ranking", ranking_command))
    app.run_polling()
